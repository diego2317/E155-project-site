<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>FPGA Overview – Robot Site</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Robot Site</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./documentation.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./fpga.html" aria-current="page"> 
<span class="menu-text">FPGA</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./mcu.html"> 
<span class="menu-text">MCU</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./team.html"> 
<span class="menu-text">The Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./results.html"> 
<span class="menu-text">Results</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./deliverables.html"> 
<span class="menu-text">Early Deliverables</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#general-overview" id="toc-general-overview" class="nav-link active" data-scroll-target="#general-overview">General Overview</a>
  <ul class="collapse">
  <li><a href="#rtl-block-diagram" id="toc-rtl-block-diagram" class="nav-link" data-scroll-target="#rtl-block-diagram">RTL Block Diagram</a></li>
  </ul></li>
  <li><a href="#ov7670-camera-pixel-capture-and-bitmasking" id="toc-ov7670-camera-pixel-capture-and-bitmasking" class="nav-link" data-scroll-target="#ov7670-camera-pixel-capture-and-bitmasking">OV7670 Camera Pixel Capture and Bitmasking</a>
  <ul class="collapse">
  <li><a href="#yuv422-format-and-y-value-luminosity-of-pixel-extraction" id="toc-yuv422-format-and-y-value-luminosity-of-pixel-extraction" class="nav-link" data-scroll-target="#yuv422-format-and-y-value-luminosity-of-pixel-extraction">YUV422 Format and Y-value (luminosity) of pixel extraction</a></li>
  <li><a href="#threshold-module-operation" id="toc-threshold-module-operation" class="nav-link" data-scroll-target="#threshold-module-operation">Threshold Module Operation</a></li>
  </ul></li>
  <li><a href="#spram-frame-buffer-and-spi-transfer" id="toc-spram-frame-buffer-and-spi-transfer" class="nav-link" data-scroll-target="#spram-frame-buffer-and-spi-transfer">SPRAM Frame Buffer and SPI Transfer</a>
  <ul class="collapse">
  <li><a href="#memory-architecture" id="toc-memory-architecture" class="nav-link" data-scroll-target="#memory-architecture">Memory Architecture</a></li>
  <li><a href="#bit-packing" id="toc-bit-packing" class="nav-link" data-scroll-target="#bit-packing">Bit Packing</a></li>
  <li><a href="#double-buffering-ping-pong" id="toc-double-buffering-ping-pong" class="nav-link" data-scroll-target="#double-buffering-ping-pong">Double Buffering (Ping-Pong)</a></li>
  <li><a href="#clock-domain-crossing-cdc" id="toc-clock-domain-crossing-cdc" class="nav-link" data-scroll-target="#clock-domain-crossing-cdc">Clock Domain Crossing (CDC)</a></li>
  <li><a href="#serial-interface-to-mcu" id="toc-serial-interface-to-mcu" class="nav-link" data-scroll-target="#serial-interface-to-mcu">Serial Interface to MCU</a></li>
  </ul></li>
  <li><a href="#pin-count" id="toc-pin-count" class="nav-link" data-scroll-target="#pin-count">Pin Count</a></li>
  <li><a href="#performance-summary" id="toc-performance-summary" class="nav-link" data-scroll-target="#performance-summary">Performance Summary</a></li>
  <li><a href="#testing-results" id="toc-testing-results" class="nav-link" data-scroll-target="#testing-results">Testing Results</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FPGA Overview</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="general-overview" class="level2">
<h2 class="anchored" data-anchor-id="general-overview">General Overview</h2>
<p>The project uses two FPGAs, each of which is independent from the other. The FPGA’s purpose is to capture the raw pixel data in YUV422 QVGA format from the OV7670 camera, and then store the bitmasked frame of Y-values of pixel data based on a pre-determined threshold by the user. This bitmasked image is stored in SPRAM frame buffer in the FPGA, before being sent to the MCU over SPI.</p>
<p><strong>System Architecture:</strong></p>
<pre><code>OV7670 Camera → Threshold Module → Frame Buffer → Serial Interface → MCU
(YUV422 QVGA) (Y-only, 1-bit/pixel)  (SPRAM)         (SPI)</code></pre>
<section id="rtl-block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="rtl-block-diagram">RTL Block Diagram</h3>
<p>The block diagram describing our RTL, which can be seen below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".\images/checkoff/rtl.jpg" class="img-fluid figure-img"></p>
<figcaption>Block Diagram</figcaption>
</figure>
</div>
</section>
</section>
<section id="ov7670-camera-pixel-capture-and-bitmasking" class="level2">
<h2 class="anchored" data-anchor-id="ov7670-camera-pixel-capture-and-bitmasking">OV7670 Camera Pixel Capture and Bitmasking</h2>
<section id="yuv422-format-and-y-value-luminosity-of-pixel-extraction" class="level3">
<h3 class="anchored" data-anchor-id="yuv422-format-and-y-value-luminosity-of-pixel-extraction">YUV422 Format and Y-value (luminosity) of pixel extraction</h3>
<p>The OV7670 camera supports sending data in multiple formats, but for our project, as we realized we only care about differentiating between two colours of the lines and the track, we could easily do this by using YUV format output, and just using the Y values of the pixel data which represent the luminosity, while ignoring the U/V values which encode the chroma/colour data. Given we chose black line on white background for our testing purposes, using Y values would be sufficient, as they would have different intensity levels.</p>
<p><strong>YUV422 Data Format:</strong></p>
<p>The YUV data sent by the camera is in the format of 8-bit Y, 8-bit U or 8-bit Y, 8-bit V, therefore, we only care about every other byte of pixel data which represent the Y values for all the 76,800 pixels we receive in the QVGA format.</p>
<pre><code>Data Stream:     Y0  U0  Y1  V0  Y2  U1  Y3  V1 ...
Bytes Captured:  Y0  --  Y1  --  Y2  --  Y3  -- ...</code></pre>
<p>This also helps us save lot of memory as we reduce the frame data by 94%</p>
<ul>
<li>Full YUV422: 76,800 pixels × 2 bytes = 153,600 bytes</li>
<li>Y-only binary: 76,800 pixels × 1 bit = 9,600 bytes</li>
</ul>
</section>
<section id="threshold-module-operation" class="level3">
<h3 class="anchored" data-anchor-id="threshold-module-operation">Threshold Module Operation</h3>
<p>The camera_capture_threshold module runs entirely in the camera pixel clock domain and processes incoming YUV422 data in real-time.</p>
<p><strong>Key Signals:</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode verilog code-with-copy"><code class="sourceCode verilog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Inputs</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">cam_pclk:</span>   Pixel clock from OV7670</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dv">cam_vsync:</span>  Frame sync <span class="op">(</span>LOW <span class="op">=</span> active frame<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dv">cam_href:</span>   Line valid <span class="op">(</span>HIGH <span class="op">=</span> pixel data valid<span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dv">cam_data:</span>   <span class="dv">8</span><span class="op">-</span>bit YUV422 data bus</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dv">threshold:</span>  <span class="dv">8</span><span class="op">-</span>bit comparison value <span class="op">(</span>our chosen value <span class="dv">141</span><span class="op">)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Outputs</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dv">wr_addr:</span>    <span class="dv">17</span><span class="op">-</span>bit pixel address <span class="op">(</span><span class="dv">0-76</span><span class="op">,</span><span class="dv">799</span><span class="op">)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="dv">wr_data:</span>    <span class="dv">1</span><span class="op">-</span>bit thresholded result <span class="op">(</span>bright<span class="op">/</span>dark<span class="op">)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dv">wr_en:</span>      Write enable pulse</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dv">frame_done:</span> Frame complete pulse</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Operation:</strong></p>
<p>The module uses a priority-based control structure with four operations:</p>
<ol type="1">
<li><strong>Frame Start</strong> (VSYNC falling edge) - Reset counters, begin capture</li>
<li><strong>Frame End</strong> (VSYNC rising edge) - Signal completion</li>
<li><strong>Pixel Capture</strong> (during frame with HREF valid) - Threshold and write Y bytes</li>
<li><strong>End of Line</strong> (HREF falling edge) - Reset line counters</li>
</ol>
<p><strong>Byte Selection Logic:</strong></p>
<p>A simple toggle mechanism parses the YUV422 stream:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode verilog code-with-copy"><code class="sourceCode verilog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>byte_select <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">begin</span>      <span class="co">// Y byte</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    wr_en   <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    wr_data <span class="op">&lt;=</span> <span class="op">(</span>data <span class="op">&gt;</span> threshold<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    byte_select <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">;</span>            <span class="co">// Next is U/V</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    byte_select <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">;</span>            <span class="co">// Skip U/V, next is Y</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This alternates between capturing Y bytes (luminance) and skipping U/V bytes (chroma).</p>
</section>
</section>
<section id="spram-frame-buffer-and-spi-transfer" class="level2">
<h2 class="anchored" data-anchor-id="spram-frame-buffer-and-spi-transfer">SPRAM Frame Buffer and SPI Transfer</h2>
<section id="memory-architecture" class="level3">
<h3 class="anchored" data-anchor-id="memory-architecture">Memory Architecture</h3>
<p>The iCE40 UP5K provides 128 KB of SPRAM (Single-Port RAM), which we use for double-buffered frame storage:</p>
<ul>
<li>Each frame: 76,800 bits = 4,800 words (16 bits/word)</li>
<li>Bank 0: Addresses 0x0000-0x12BF</li>
<li>Bank 1: Addresses 0x1300-0x257F</li>
<li>Total usage: 9,600 words (15% of SPRAM capacity)</li>
</ul>
</section>
<section id="bit-packing" class="level3">
<h3 class="anchored" data-anchor-id="bit-packing">Bit Packing</h3>
<p>Since the threshold module outputs 1 bit per pixel, data is packed into 16-bit words:</p>
<pre><code>Pixel Address [16:0]:
  Bits [16:4] → Word address (0-4,799)
  Bits [3:0]  → Bit position (0-15)</code></pre>
<p>When 16 bits accumulate in the camera domain, they’re latched and transferred to the system clock domain (48 MHz) for SPRAM write.</p>
</section>
<section id="double-buffering-ping-pong" class="level3">
<h3 class="anchored" data-anchor-id="double-buffering-ping-pong">Double Buffering (Ping-Pong)</h3>
<p>The frame buffer uses ping-pong buffering to enable simultaneous camera write and MCU read:</p>
<ol type="1">
<li>Camera writes to Bank A, MCU reads from Bank B</li>
<li>On frame completion, banks swap roles</li>
<li>Camera immediately starts writing to Bank B</li>
<li>MCU continues reading completed Bank A</li>
<li>Process repeats continuously</li>
</ol>
<p>This ensures no frame drops at the camera’s frame rate, even if the MCU lags behind by one frame.</p>
</section>
<section id="clock-domain-crossing-cdc" class="level3">
<h3 class="anchored" data-anchor-id="clock-domain-crossing-cdc">Clock Domain Crossing (CDC)</h3>
<p>The system operates across two asynchronous clock domains:</p>
<ul>
<li>Camera domain: 2.5 MHz (from OV7670)</li>
<li>System domain: 48 MHz (internal oscillator)</li>
</ul>
<p>All cross-domain signals use 3-stage synchronizers to prevent metastability.</p>
<p>Data is latched in the source domain before the control signal toggles, ensuring stability during crossing.</p>
</section>
<section id="serial-interface-to-mcu" class="level3">
<h3 class="anchored" data-anchor-id="serial-interface-to-mcu">Serial Interface to MCU</h3>
<p>The FPGA implements a SPI slave interface:</p>
<p><strong>Protocol:</strong></p>
<ol type="1">
<li>FPGA asserts frame_ready when new frame available</li>
<li>MCU generates SCK pulses (3-48 MHz recommended)</li>
<li>FPGA outputs one bit per SCK falling edge</li>
<li>After 76,800 bits, FPGA deasserts frame_ready</li>
</ol>
<p>The module uses priority-based logic:</p>
<ol type="1">
<li><strong>New frame event</strong> - Reset address, load first word from SPRAM</li>
<li><strong>Load complete</strong> - Capture SPRAM data into shift register</li>
<li><strong>Shift on MCU clock</strong> - Output bits serially, fetch next word when needed</li>
</ol>
<p><strong>Timing:</strong></p>
<p>At 10 MHz SCK: 76,800 bits / 10 MHz = 7.68 ms per frame</p>
<p>Camera frame period: 33.33 ms (30 fps)</p>
</section>
</section>
<section id="pin-count" class="level2">
<h2 class="anchored" data-anchor-id="pin-count">Pin Count</h2>
<ul>
<li><strong>Camera interface:</strong> 11 pins (pclk, vsync, href, data[7:0])</li>
<li><strong>MCU interface:</strong> 3 pins (sck, mosi, frame_ready)</li>
<li><strong>System:</strong> 1 pin (reset)</li>
<li><strong>Total</strong>: 14 I/O pins</li>
</ul>
</section>
<section id="performance-summary" class="level2">
<h2 class="anchored" data-anchor-id="performance-summary">Performance Summary</h2>
<p>Camera Capture:</p>
<ul>
<li>Frame rate: 30 fps</li>
<li>Pixel rate: 2.3 Mpixels/sec</li>
<li>Bit rate: 2.3 Mbits/sec (after thresholding)</li>
</ul>
</section>
<section id="testing-results" class="level2">
<h2 class="anchored" data-anchor-id="testing-results">Testing Results</h2>
<p>The system has been validated with:</p>
<ul>
<li>Testbench to verify the module</li>
<li>Continuous frame capture at QVGA resolution</li>
<li>Correct YUV422 byte selection (Y-only)</li>
<li>Threshold discrimination (black line detection)</li>
<li>Bank swapping without corruption</li>
<li>Proper Serial readout over SPI</li>
</ul>
<p>The hardware has been tested extensively and performs reliably in the line-following application.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/diego2317\.github\.io\/E155-project-site\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>